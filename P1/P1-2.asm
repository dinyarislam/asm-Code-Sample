#=================================================================
# Copyright 2021 Georgia Tech.  All rights reserved.
# The materials provided by the instructor in this course are for
# the use of the students currently enrolled in the course.
# Copyrighted course materials may not be further disseminated.
# This file must not be made publicly available anywhere.
# =================================================================
#
# Locate Part in Pile
#
# P1-2
# Student Name: Dinyar Islam
# Date: 15 October 2021
#
# This program locates the part in a pile that has a specified color, and
# reports its bounding box:
# <offset of upper left corner, offset of lower right corner>.
# Offsets are specified as linear offsets from the Pile image base.
#
# SWI I/O:
# Create Pile and Choose Color swi 598 takes Pile base address in $1 and
# returns color to find in $3 and also fills pile array into memory
# starting at base address (1 byte/pixel)
#
# Bounding box is given to Report Part BBox swi 599 in $2:
# as linear offsets from Pile base of bbox corners: [UpperLeft | LowerRight]
# packed into the upper and lower 16 bits of $2.
# Oracle returns correct answer in $3.
#
# Mark pixel swi 547 takes linear offset from Pile address as input
# and highlights pixel at that offset. Returns nothing.
#
#===========================================================================
# CHANGE LOG: brief description of changes made from P1-2-shell.asm
# to this version of code.
# Date  Modification
# 10/9 Created another a more efficient algorithm that has less DI
# 10/9 Tested for accuracy and bugs and modified code accordingly
# 10/12 Reduced SI by deleting unused statements
# 10/12 Reduced DI by constricting the looping to only iterate through necessary pixels
# 10/13 Tested for edge cases and added edge case handling statements
# 10/15 Reduced register data by reusing registers
#===========================================================================

.data
Pile:  .alloc	1024

.text

Locate:	addi	$1, $0, Pile		# point to array base

# ***************************************************************************
# Easter egg -- you can use this in debugging to load in a testcase that was
# generated by Misasim earlier and dumped to memory.  Put -1 into $2 and put
# color code (e.g., 4 for blue) into $3 before calling swi 598.
#	addi    $2, $0, -1		# load in pile from file ** Debugging
#	addi    $3, $0, 5		# part color to locate ** Debugging
# BE SURE TO COMMENT OUT ALL DEBUGGING FEATURES BEFORE SUBMITTING YOUR CODE
# ***************************************************************************

	swi	598			# create pile and select color
					# $3 holds part color

        # your code goes here
				addi $4, $0, 64			# Intializing the upper-left pixel's row
				addi $7, $0, 0			#	Intializing the lower-right pixel's column
				addi $1, $0, 65			# Initializing pixel number

Loop:   lbu  $13, Pile($1) 	# Loading pixel color
				beq  $13, $3, Start # If current pixel color == color to find, move to Start
Next:   addi $1, $1, 1			# Incrementing pixel number
				j  Loop							# Loop back to Loop

Start:	divu $1, $4					# divide $1 by $4
				mflo $8 						# Intializing the row index i.e. row = $1 div $4
				mfhi $5							# Intializing the upper-left pixel's column = $1 mod $4
				addi $2, $0, 63			# Initializing $2 for comparison
				mfhi $9 						# Intializing the column index

For2:		beq  $9, $2, Calc	  # if col == 63, move to Inc2
				sll  $12, $8, 6 		# Multiplying row times 64
				add  $12, $12, $9		# adding col to $12 to calculate pixel number
				lbu  $13, Pile($12) # Loading pixel color

If0:		bne  $13, $3, Inc1  # If current pixel color != color to find, move to Inc1
				add  $4, $0, $8			# Updating upper-left pixel's row
        addi $10, $12, 64   # Updating pixel number
        add  $6, $0, $4     # Initializing lower-right pixel's row

If1:    lbu  $13, Pile($10) # Loading pixel color
        beq  $13, $3, Bod1  # is current pixel color == color to find, move to Bod1
				beq  $13, $0, Inc1	# if current pixel color == black, move to Inc1
        addi $1, $10, 64    # Updating pixel number
        lbu  $13, Pile($1)  # Loading pixel color
        beq  $13, $3, Bod1	# if current pixel color == color to find, move to Row1

Inc1:		addi $9, $9, 1      # Incrementing column counter i.e. col
        j  For2        			# loop back to inner loop start



While1: lbu  $13, Pile($10) # Loading pixel color
        beq  $13, $3, Bod1  # is current pixel color == color to find, move to Bod1
				beq  $13, $0, Calc  # if current pixel color == black, move to Calc
        addi $1, $10, 64    # Updating pixel number
        lbu  $13, Pile($1)  # Loading pixel color
        bne  $13, $3, Calc  # is current pixel color != color to find, move to Calc
Bod1:   addi $6, $6, 1      # Updating lower-right pixel's row
				addi $1, $10, 1			# Updating the pixel number
				lbu  $11, Pile($1)	# Loading pixel color
				beq  $11, $3, Updt	# if pixel color == color to find, move to Updt
				addi $1, $1, -2			# Decrement pixel number
				lbu  $11, Pile($1)	# Loading pixel color
				bne  $11, $3, Pix1	# if pixel color != color to find, move to Pix1
Updt: 	add  $14, $0, $1		# $14 = pixel number (for finding column values)
				j  Init1						# jump to Init2
Pix1: 	addi $10, $10, 64   # Updating pixel number
        j  While1						# Loop back to While1

Init1:  addi $9, $0, 1      # Initializing col (start of function)
				addiu $11, $0, 64		# $11 = 64 for div operation
				divu $14, $11				# $14 divided by $11
				mflo $8							# $8 = $14 div $11 i.e. the row number
        sll  $14, $8, 6 		# Multiplying row times 64
For3: 	add  $12, $14, $9		# adding col to $12 to calculate pixel number
				lbu  $13, Pile($12) # Loading pixel color
        beq  $13, $3, Col1	# If pixel color == color to find, move to Col1

Inc3:   addi $9, $9, 1			# Incrementing column counter i.e. column
        j  For3             # loop back to outer loop start

Col1:   slt  $2, $9, $5			# Is col < upper-left pixel's column?
				beq  $2, $0, Con1		# If col >= upper-left pixel's column move to Con1
				add  $5, $0, $9			# Updating upper-left pixel's column

Con1:   addiu $9, $0, 62		# Initializing col
				sll  $14, $8, 6 		# Multiplying row times 64
For4:   add  $12, $14, $9		# adding col to $12 to calculate pixel number
        lbu  $13, Pile($12) # Loading pixel color
        beq  $13, $3, Col2	# if pixel color == color to find, move to Col2

Inc4:   addi $9, $9, -1			# Incrementing column counter i.e. column
        j  For4             # loop back to outer loop start

Col2:   slt  $2, $7, $9			# Is lower-right pixel's column < column?
				beq  $2, $0, jmp1		# If lower-right pixel's column >= column move to jmp1
				add  $7, $0, $9			# Updating lower-right pixel's column

jmp1:   j  Pix1							# return to Pix1

Calc:   lbu  $13, Pile($10) # Loading pixel color
        beq  $13, $0, Last  # is current pixel color == black to find, move to Cont
				addi $2, $0, 64			# Initializing $2 for calculation
lrow:		divu $10, $2				# divide $10 by $2
				beq  $13, $3, Cont  # if pixel color == color to find, move to Cont
				mfhi $9							# Initializing col = $10 mod $2
				beq  $9, $7, Last		# if col == lower-right pixel's column, move to Last
				addi $10, $10, 1    # Incrementing pixel number
				lbu  $13, Pile($10) # Loading pixel color
				j  lrow							# Loop back to lrow
Cont:		mflo $6							# lower-right row = $10 div $2
Last: 	sll  $4, $4, 6			# Upper-left pixel's row * 64
				addi $11, $7, 1			# Updating column counter
				add  $10, $11, $4		# pixel number
				lbu  $10, Pile($10) # Loading pixel color
				bne  $10, $3, Done  # if current pixel color != color to find, move to Done
				add  $7, $0, $11    # Updating lower-right pixel's column
Done:		add  $4, $4, $5			# UpperLeft = $4 + upper-left pixel's column
				sll  $6, $6, 6 	    # Lower-right pixel's row * 64
				add  $6, $6, $7			# LowerRight = $6 + lower-right pixel's column
				sll  $2, $4, 16			# Shifting the value in $4 by 16 places and storing value in $2
				or   $2, $2, $6     # Or with value in $6


	# call report bbox swi
	# oracle returns correct answer in $3

	swi	599			# submit answer and check
	jr	$31			# return to caller
